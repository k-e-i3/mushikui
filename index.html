<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ€è¡“å£«è©¦é¨“ç”¨çµ±åˆå­¦ç¿’ãƒ„ãƒ¼ãƒ«</title>
    <style>
        :root {
            --base-color: #4169E1;
            --highlight-color: #FFF1AB;
            --danger-color: #DC143C;
            --editing-color: #d1e7fd;
            --correct-color: #c8e6c8;
            --incorrect-color: #ffcccb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'MS Gothic', 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯', monospace;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            background-color: white;
            padding: 12px 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        label {
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
        }

        select, button, input[type="range"] {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
        }

        #textSelect {
            width: 120px;
        }

        button.primary {
            background-color: var(--base-color);
            color: white;
            border-color: var(--base-color);
            min-width: 60px;
        }

        button.primary:hover {
            background-color: #1E90FF;
        }

        /* ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ†ãƒŠã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .editor-container {
            margin: 10px 0;
        }

        .editor-section {
            margin-bottom: 5px;
        }

        .editor-toggle {
            width: 100%;
            text-align: left;
            padding: 8px 15px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-toggle:hover {
            background-color: #e9ecef;
        }

        .editor-panel {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-top: none;
            padding: 15px;
        }

        .editor-panel textarea {
            width: 100%;
            height: 120px;
            font-size: 14px;
            padding: 8px;
            border: 2px solid var(--base-color);
            border-radius: 5px;
            font-family: inherit;
            resize: vertical;
        }

        .editor-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .keyword-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tab-btn {
            padding: 5px 15px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }

        .tab-btn:hover {
            background-color: #f8f9fa;
        }

        .tab-btn.active {
            background-color: var(--base-color);
            color: white;
        }

        .keyword-input {
            min-height: 150px;
        }

        /* ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è™«é£Ÿã„ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .keyword-mask-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .keyword-checkbox-group {
            display: flex;
            gap: 15px;
        }

        .keyword-checkbox-group label {
            display: flex;
            align-items: center;
            gap: 3px;
            font-weight: normal;
        }

        .counter {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .manuscript-paper {
            position: relative;
            width: fit-content;
            margin: 0 auto;
        }

        .page {
            margin-bottom: 30px;
            position: relative;
        }

        .page-number {
            position: absolute;
            bottom: -25px;
            right: 0;
            font-size: 14px;
            color: #666;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(24, 30px);
            grid-auto-rows: 30px;
            border: 2px solid var(--base-color);
        }

        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid var(--base-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            background-color: white;
            transition: all 0.3s ease;
        }

        .cell.highlight {
            background-color: var(--highlight-color);
            animation: pulse 1s ease-in-out;
        }

        .cell.hidden {
            background-color: #e0e0e0;
            cursor: pointer;
            color: #888;
        }

        .cell.hidden:hover {
            background-color: #d0d0d0;
        }

        .cell.editing {
            background-color: var(--editing-color);
            border: 2px solid var(--base-color);
        }

        .cell.correct {
            background-color: var(--correct-color);
            color: #333;
        }

        .cell.incorrect {
            background-color: var(--incorrect-color);
            color: #333;
        }

        .cell.half-width {
            font-size: 14px;
            letter-spacing: -1px;
        }

        .cell.punctuation {
            color: #FF1493;
        }

        .cell .end-punctuation {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            color: #FF1493;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ */
        #popup-editor {
            display: none;
            position: absolute;
            background-color: white;
            border: 2px solid var(--base-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
            z-index: 1000;
            min-width: 250px;
            max-width: 500px;
        }

        #popup-editor.incorrect-feedback {
            animation: shake 0.5s;
            border-color: var(--danger-color);
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); }
            75% { transform: translateX(-6px); }
        }

        #popup-input {
            width: 100%;
            padding: 8px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 10px;
            font-family: inherit;
        }

        .popup-buttons {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        .popup-buttons button {
            padding: 6px 12px;
            font-size: 14px;
            border-radius: 4px;
        }

        #feedback-message {
            margin-top: 8px;
            padding: 6px;
            border-radius: 3px;
            text-align: center;
            font-weight: bold;
            font-size: 13px;
        }

        #feedback-message.error {
            background-color: var(--incorrect-color);
            color: var(--danger-color);
        }

        @media print {
            body {
                background-color: white;
                padding: 0;
            }
            .container {
                box-shadow: none;
                padding: 0;
            }
            .controls-container,
            .editor-container,
            #popup-editor {
                display: none;
            }
            .page {
                page-break-after: always;
                margin-bottom: 0;
            }
            .page:last-child {
                page-break-after: auto;
            }
        }

        @media (max-width: 800px) {
            .grid {
                grid-template-columns: repeat(24, 25px);
            }
            .cell {
                width: 25px;
                height: 25px;
                font-size: 14px;
            }
            .controls {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls-container">
            <!-- å…¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’1è¡Œã« -->
            <div class="controls">
                <div class="control-group">
                    <button id="playPauseBtn" class="primary">å†ç”Ÿ</button>
                </div>
                <div class="control-group">
                    <label>é€Ÿåº¦:</label>
                    <input type="range" id="speedSlider" min="0.1" max="7" step="0.1" value="1.0" style="width: 60px;">
                    <span id="speedValue">1.0</span>s
                </div>
                <div class="control-group">
                    <input type="checkbox" id="speechToggle">
                    <label for="speechToggle">èª­</label>
                </div>
                <div class="control-group">
                    <label for="speechRateSlider">èª­é€Ÿ:</label>
                    <input type="range" id="speechRateSlider" min="0.05" max="3" step="0.05" value="0.8" style="width: 70px;">
                    <span id="speechRateValue">0.8</span>
                    <button onclick="toggleSlowMode()" style="padding: 2px 6px; font-size: 11px; margin-left: 5px;">è¶…ä½é€Ÿ</button>
                </div>
                <div class="control-group">
                    <input type="checkbox" id="autopauseToggle" checked>
                    <label for="autopauseToggle">è™«åœ</label>
                </div>
                <div class="control-group">
                    <div class="keyword-checkbox-group">
                        <label>
                            <input type="checkbox" id="keywordNew" checked>
                            <span style="color: #dc3545;">âŒè‹¦æ‰‹</span>
                        </label>
                        <label>
                            <input type="checkbox" id="keywordLearning" checked>
                            <span style="color: #ffc107;">â“ç¿’å¾—ä¸­</span>
                        </label>
                        <label>
                            <input type="checkbox" id="keywordMastered">
                            <span style="color: #28a745;">â­•å®Œç’§</span>
                        </label>
                    </div>
                </div>
                <div class="control-group">
                    <select id="pageCount">
                        <option value="1">1æš</option>
                        <option value="2">2æš</option>
                        <option value="3" selected>3æš</option>
                        <option value="4">4æš</option>
                        <option value="5">5æš</option>
                        <option value="6">6æš</option>
                        <option value="7">7æš</option>
                        <option value="8">8æš</option>
                        <option value="9">9æš</option>
                        <option value="10">10æš</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ†ãƒŠ -->
        <div class="editor-container">
            <!-- æœ¬æ–‡ã‚¨ãƒ‡ã‚£ã‚¿ -->
            <div class="editor-section">
                <button onclick="toggleEditor('main')" class="editor-toggle">
                    <span>ğŸ“ æœ¬æ–‡</span>
                    <span id="main-toggle-icon">â–¶</span>
                </button>
                <div id="main-editor" class="editor-panel" style="display: none;">
                    <textarea id="textInput" placeholder="å­¦ç¿’ã—ãŸã„æ–‡ç« ã‚’å…¥åŠ›ã™ã‚‹ã‹ã€ä¸Šã®ãƒ†ã‚­ã‚¹ãƒˆé¸æŠã‹ã‚‰é¸ã‚“ã§ãã ã•ã„..."></textarea>
                    <div class="editor-controls">
                        <button onclick="saveMainText()" class="primary">ä¿å­˜</button>
                        <select id="textSelect">
                            <option value="">GitHubã‹ã‚‰é¸æŠ...</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ -->
            <div class="editor-section">
                <button onclick="toggleEditor('keywords')" class="editor-toggle">
                    <span>ğŸ”¤ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰</span>
                    <span id="keywords-toggle-icon">â–¶</span>
                </button>
                <div id="keywords-editor" class="editor-panel" style="display: none;">
                    <div class="keyword-tabs">
                        <button onclick="selectKeywordTab('new')" class="tab-btn active">âŒ è‹¦æ‰‹</button>
                        <button onclick="selectKeywordTab('learning')" class="tab-btn">â“ ç¿’å¾—ä¸­</button>
                        <button onclick="selectKeywordTab('mastered')" class="tab-btn">â­• å®Œç’§</button>
                    </div>
                    <textarea id="keyword-textarea" class="keyword-input" 
                        placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›..."></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button onclick="saveKeywords()" class="primary">ä¿å­˜</button>
                        <button onclick="resetKeywords()" class="secondary">ãƒªã‚»ãƒƒãƒˆ</button>
                        <button id="moveLeftBtn" onclick="moveSelectedKeyword('left')" style="background-color: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; display: none;">â†</button>
                        <button id="moveRightBtn" onclick="moveSelectedKeyword('right')" style="background-color: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px;">â†’</button>
                    </div>
                    <div id="keyword-move-info" style="margin-top: 10px; font-size: 12px; color: #666;">
                        â€»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ç§»å‹•ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã‹ã€3å›æ­£è§£ã§è‡ªå‹•ç§»å‹•
                    </div>
                </div>
            </div>
        </div>

        <div class="counter">
            æ–‡å­—æ•°: <span id="charCount">0</span> / <span id="maxChars">1800</span>
            <button onclick="toggleMistakeLog()" style="margin-left: 15px; padding: 4px 8px; font-size: 12px;">é–“é•ã„ãƒ­ã‚°</button>
            <button onclick="toggleSoundTest()" style="margin-left: 5px; padding: 4px 8px; font-size: 12px;">éŸ³é¸æŠ</button>
            <button onclick="toggleSyncPanel()" style="margin-left: 5px; padding: 4px 8px; font-size: 12px;">ğŸ“± åŒæœŸ</button>
        </div>

        <!-- éŸ³é¸æŠãƒ‘ãƒãƒ« -->
        <div id="sound-test-panel" style="display: none; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px;">
            <h3 style="margin-bottom: 10px; color: #28a745;">ğŸµ æ­£è§£éŸ³ã‚’é¸æŠ</h3>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                <button onclick="testSound(1)" style="padding: 6px 12px; font-size: 12px;">ãƒ”ãƒ³ãƒãƒ³</button>
                <button onclick="testSound(2)" style="padding: 6px 12px; font-size: 12px;">ã‚·ãƒ³ãƒ—ãƒ«</button>
                <button onclick="testSound(3)" style="padding: 6px 12px; font-size: 12px;">ãƒ”ã‚¢ãƒ</button>
                <button onclick="testSound(4)" style="padding: 6px 12px; font-size: 12px;">æœ¨ç´</button>
                <button onclick="testSound(5)" style="padding: 6px 12px; font-size: 12px;">ãƒ‰ãƒ¬ãƒŸ</button>
                <button onclick="testSound(6)" style="padding: 6px 12px; font-size: 12px;">ãƒ“ãƒ¼ãƒ—</button>
                <button onclick="testSound(0)" style="padding: 6px 12px; font-size: 12px; background-color: #dc3545; color: white;">éŸ³ãªã—</button>
            </div>
            <p style="margin-bottom: 10px; font-size: 13px;">ç¾åœ¨é¸æŠ: <span id="selected-sound">ãƒ”ãƒ³ãƒãƒ³</span></p>
            <div style="margin-top: 10px;">
                <button onclick="toggleSoundTest()" style="background-color: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px;">é–‰ã˜ã‚‹</button>
            </div>
        </div>

        <!-- é–“é•ã„ãƒ­ã‚°ãƒ‘ãƒãƒ« -->
        <div id="mistake-log-panel" style="display: none; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px;">
            <h3 style="margin-bottom: 10px; color: #dc3545;">ğŸš¨ é–“é•ã„ãƒ­ã‚°</h3>
            <div id="mistake-list"></div>
            <div style="margin-top: 10px;">
                <button onclick="clearMistakeLog()" style="background-color: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px;">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
                <button onclick="mistakeOnlyMode()" style="background-color: #ffc107; color: black; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; margin-left: 5px;">è‹¦æ‰‹å•é¡Œã®ã¿</button>
            </div>
        </div>

        <!-- ãƒ‡ãƒ¼ã‚¿åŒæœŸãƒ‘ãƒãƒ« -->
        <div id="sync-panel" style="display: none; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px;">
            <h3 style="margin-bottom: 10px; color: #4169E1;">ğŸ“± ãƒ‡ãƒã‚¤ã‚¹é–“ãƒ‡ãƒ¼ã‚¿åŒæœŸ</h3>
            <div style="margin-bottom: 15px;">
                <p style="font-size: 13px; margin-bottom: 10px;">ç¾åœ¨ã®ãƒ‡ãƒã‚¤ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä»–ã®ãƒ‡ãƒã‚¤ã‚¹ã«ã‚³ãƒ”ãƒ¼ï¼š</p>
                <button onclick="copyDataToClipboard()" style="background-color: #4169E1; color: white; border: none; padding: 8px 16px; border-radius: 4px;">ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼</button>
            </div>
            <div>
                <p style="font-size: 13px; margin-bottom: 10px;">ä»–ã®ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼š</p>
                <textarea id="sync-data-input" placeholder="ã“ã“ã«ã‚³ãƒ”ãƒ¼ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘..." style="width: 100%; height: 100px; font-size: 12px; margin-bottom: 10px;"></textarea>
                <button onclick="loadDataFromClipboard()" style="background-color: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px;">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿</button>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="toggleSyncPanel()" style="background-color: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px;">é–‰ã˜ã‚‹</button>
            </div>
        </div>

        <div class="manuscript-paper" id="manuscriptPaper">
            <!-- ã“ã“ã«ãƒšãƒ¼ã‚¸ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
        </div>
    </div>

    <!-- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ -->
    <div id="popup-editor">
        <div id="keyword-level-display" style="text-align: center; margin-bottom: 10px;">
            <span style="font-weight: bold; font-size: 16px;">ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«: </span>
            <span id="current-level" style="font-size: 16px;"></span>
        </div>
        <div id="keyword-info" style="text-align: center; margin-bottom: 10px; font-size: 14px;">
            <span id="keyword-display" style="font-weight: bold;"></span>
            <span id="keyword-length" style="color: #666;"></span>
        </div>
        <div id="keyword-stats-display" style="text-align: center; margin-bottom: 10px; font-size: 13px; color: #666;">
            <span id="correct-count"></span>
            <span id="mistake-count" style="margin-left: 10px;"></span>
        </div>
        <input type="text" id="popup-input" placeholder="ã“ã“ã«ç­”ãˆã‚’å…¥åŠ›">
        <div class="popup-buttons">
            <button id="submitBtn" class="primary">ç¢ºå®š</button>
            <button id="cancelBtn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="showAnswerBtn">ç­”ãˆã‚’è¦‹ã‚‹</button>
        </div>
        <div style="margin-top: 10px; text-align: center;">
            <span style="font-size: 12px; color: #666;">ãƒ¬ãƒ™ãƒ«å¤‰æ›´ï¼š</span>
            <button onclick="moveKeywordToLevel('new')" style="background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin: 0 2px;">è‹¦æ‰‹</button>
            <button onclick="moveKeywordToLevel('learning')" style="background-color: #ffc107; color: black; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin: 0 2px;">ç¿’å¾—ä¸­</button>
            <button onclick="moveKeywordToLevel('mastered')" style="background-color: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin: 0 2px;">å®Œç’§</button>
        </div>
        <div style="margin-top: 5px; text-align: center;">
            <span style="font-size: 11px; color: #666;">å¿…è¦æ­£è§£æ•°: </span>
            <select id="required-correct-count" onchange="updateRequiredCount()" style="font-size: 11px; padding: 2px;">
                <option value="1">1å›</option>
                <option value="2">2å›</option>
                <option value="3" selected>3å›</option>
                <option value="4">4å›</option>
                <option value="5">5å›</option>
                <option value="7">7å›</option>
                <option value="10">10å›</option>
            </select>
            <span style="font-size: 11px; color: #666;">ã§æ¬¡ãƒ¬ãƒ™ãƒ«ã¸</span>
        </div>
        <div id="feedback-message"></div>
    </div>

    <script>
        // DOMè¦ç´ ã®å–å¾—
        const elements = {
            textInput: document.getElementById('textInput'),
            manuscriptPaper: document.getElementById('manuscriptPaper'),
            pageCountSelect: document.getElementById('pageCount'),
            textSelect: document.getElementById('textSelect'),
            keywordNew: document.getElementById('keywordNew'),
            keywordLearning: document.getElementById('keywordLearning'),
            keywordMastered: document.getElementById('keywordMastered'),
            playPauseBtn: document.getElementById('playPauseBtn'),
            speedSlider: document.getElementById('speedSlider'),
            speedValue: document.getElementById('speedValue'),
            speechToggle: document.getElementById('speechToggle'),
            autopauseToggle: document.getElementById('autopauseToggle'),
            charCount: document.getElementById('charCount'),
            maxChars: document.getElementById('maxChars'),
            popupEditor: document.getElementById('popup-editor'),
            popupInput: document.getElementById('popup-input'),
            submitBtn: document.getElementById('submitBtn'),
            cancelBtn: document.getElementById('cancelBtn'),
            showAnswerBtn: document.getElementById('showAnswerBtn'),
            speechRateSlider: document.getElementById('speechRateSlider'),
            speechRateValue: document.getElementById('speechRateValue'),
            keywordTextarea: document.getElementById('keyword-textarea'),
            feedbackMessage: document.getElementById('feedback-message')
        };

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
        let state = {
            isPlaying: false,
            currentWordIndex: -1,
            timer: null,
            speed: 1000,
            voices: [],
            currentEditingProblem: null,
            currentEditingProblemIndex: -1,
            problems: [],
            characterData: [],
            speechRate: 0.8,
            mistakeLog: [],
            keywords: {
                new: [],
                learning: [],
                mastered: []
            },
            currentKeywordTab: 'new',
            keywordStats: {}, // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã”ã¨ã®æ­£è§£å›æ•°ã‚’è¨˜éŒ²
            slowMode: false, // è¶…ä½é€Ÿãƒ¢ãƒ¼ãƒ‰
            requiredCounts: { // ãƒ¬ãƒ™ãƒ«ç§»å‹•ã«å¿…è¦ãªæ­£è§£å›æ•°
                new: 3,
                learning: 3
            }
        };

        const githubInfo = { username: 'k-e-i3', repo: 'mushikui' };

        // éŸ³éŸ¿åŠ¹æœç”¨
        let audioContext = null;
        let selectedSoundType = 1; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ãƒ”ãƒ³ãƒãƒ³

        // ã‚¨ãƒ‡ã‚£ã‚¿ã®ãƒˆã‚°ãƒ«é–¢æ•°
        function toggleEditor(type) {
            const editorId = type === 'main' ? 'main-editor' : 'keywords-editor';
            const iconId = type === 'main' ? 'main-toggle-icon' : 'keywords-toggle-icon';
            
            const editor = document.getElementById(editorId);
            const icon = document.getElementById(iconId);
            
            if (editor.style.display === 'none') {
                editor.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                editor.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¿ãƒ–ã®é¸æŠ
        function selectKeywordTab(tab) {
            state.currentKeywordTab = tab;
            
            // ã‚¿ãƒ–ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®å†…å®¹ã‚’æ›´æ–°
            elements.keywordTextarea.value = state.keywords[tab].join('\n');
            
            // ç§»å‹•ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
            const moveLeftBtn = document.getElementById('moveLeftBtn');
            const moveRightBtn = document.getElementById('moveRightBtn');
            const moveInfo = document.getElementById('keyword-move-info');
            
            if (tab === 'new') {
                moveLeftBtn.style.display = 'none';
                moveRightBtn.style.display = 'block';
                moveInfo.innerHTML = `â€»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ç§»å‹•ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã‹ã€<strong>${state.requiredCounts.new}å›æ­£è§£</strong>ã§ç¿’å¾—ä¸­ã¸è‡ªå‹•ç§»å‹•`;
            } else if (tab === 'learning') {
                moveLeftBtn.style.display = 'block';
                moveRightBtn.style.display = 'block';
                moveInfo.innerHTML = `â€»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ç§»å‹•ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã‹ã€<strong>${state.requiredCounts.learning}å›æ­£è§£</strong>ã§å®Œç’§ã¸è‡ªå‹•ç§»å‹•`;
            } else {
                moveLeftBtn.style.display = 'block';
                moveRightBtn.style.display = 'none';
                moveInfo.innerHTML = 'â€»å®Œç’§ãƒ¬ãƒ™ãƒ«ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ç¿’å¾—ä¸­ã«æˆ»ã™ã“ã¨ãŒã§ãã¾ã™';
            }
        }

        // æœ¬æ–‡ã®ä¿å­˜
        function saveMainText() {
            saveTextToLocal();
            alert('æœ¬æ–‡ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ä¿å­˜
        function saveKeywords() {
            const text = elements.keywordTextarea.value.trim();
            state.keywords[state.currentKeywordTab] = text ? text.split('\n').map(k => k.trim()).filter(k => k) : [];
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            localStorage.setItem('gijutsushiKeywords_' + state.currentKeywordTab, JSON.stringify(state.keywords[state.currentKeywordTab]));
            
            // è™«é£Ÿã„å•é¡Œã‚’å†ç”Ÿæˆ
            updateManuscriptPreserveState();
            
            alert(`${state.currentKeywordTab === 'new' ? 'è‹¦æ‰‹' : state.currentKeywordTab === 'learning' ? 'ç¿’å¾—ä¸­' : 'å®Œç’§'}ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
        }

async function resetKeywords() {
    if (!confirm('å…¨ã¦ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆè‹¦æ‰‹ã€ç¿’å¾—ä¸­ã€å®Œç’§ï¼‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã€GitHubã‹ã‚‰æœ€æ–°ç‰ˆã‚’å†å–å¾—ã—ã¾ã™ã‹ï¼Ÿ\nç¾åœ¨ã®ç¿’ç†Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã¯å¤±ã‚ã‚Œã¾ã™ã€‚')) {
        return;
    }

    const levels = ['new', 'learning', 'mastered'];
    
    try {
        // 1. å…¨ã¦ã®ãƒ¬ãƒ™ãƒ«ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å–å¾—ã‚’ä¸¦è¡Œã—ã¦å®Ÿè¡Œ
        await Promise.all(levels.map(async (level) => {
            const storageKey = `gijutsushiKeywords_${level}`;
            const url = `https://${githubInfo.username}.github.io/${githubInfo.repo}/keyword_${level}.txt?t=${new Date().getTime()}`;

            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
            localStorage.removeItem(storageKey);

            // GitHubã‹ã‚‰å†å–å¾—
            const response = await fetch(url, { cache: 'no-store' });
            if (!response.ok) {
                // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºã«ã™ã‚‹ï¼ˆã‚¨ãƒ©ãƒ¼ã«ã—ãªã„ï¼‰
                console.log(`keyword_${level}.txt ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
                state.keywords[level] = [];
                localStorage.setItem(storageKey, JSON.stringify([]));
                return;
            }

            const text = await response.text();
            const keywords = text.split('\n').map(k => k.trim()).filter(k => k);
            
            // stateã¨ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’æ›´æ–°
            state.keywords[level] = keywords;
            localStorage.setItem(storageKey, JSON.stringify(keywords));
        }));
        
        // 2. ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çµ±è¨ˆã¨é–“é•ã„ãƒ­ã‚°ã‚‚ãƒªã‚»ãƒƒãƒˆ
        state.keywordStats = {};
        localStorage.removeItem('gijutsushiKeywordStats');
        clearMistakeLog(); // æ—¢å­˜ã®é–“é•ã„ãƒ­ã‚°ã‚¯ãƒªã‚¢é–¢æ•°ã‚’å‘¼ã³å‡ºã™
        
        // 3. ç”»é¢è¡¨ç¤ºã‚’æ›´æ–°
        // ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ã‚¿ãƒ–ã®ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚’æ›´æ–°
        elements.keywordTextarea.value = state.keywords[state.currentKeywordTab].join('\n');
        
        // åŸç¨¿ç”¨ç´™ã®è™«é£Ÿã„è¡¨ç¤ºã‚’æ›´æ–°
        updateManuscript();

        alert('å…¨ã¦ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆãŒå®Œäº†ã—ã¾ã—ãŸï¼');

    } catch (e) {
        alert("ãƒªã‚»ãƒƒãƒˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
        console.error(e);
    }
}

        // è™«é£Ÿã„çŠ¶æ…‹ã‚’ä¿æŒã—ãªãŒã‚‰æ›´æ–°
        function updateManuscriptPreserveState() {
            // ç¾åœ¨ã®è™«é£Ÿã„çŠ¶æ…‹ã‚’ä¿å­˜
            const preservedProblems = [];
            state.problems.forEach(problem => {
                // ã¾ã éš ã•ã‚Œã¦ã„ã‚‹å•é¡Œã®ã¿ä¿å­˜
                if (problem.cells.some(cell => cell.classList.contains('hidden'))) {
                    preservedProblems.push({
                        answer: problem.answer,
                        startIndex: problem.startIndex,
                        endIndex: problem.endIndex
                    });
                }
            });
            
            // é€šå¸¸ã®æ›´æ–°å‡¦ç†
            updateManuscript();
            
            // ä¿å­˜ã•ã‚ŒãŸå•é¡Œã‚’å¾©å…ƒ
            preservedProblems.forEach(preserved => {
                // æ–°ã—ã„å•é¡Œãƒªã‚¹ãƒˆã‹ã‚‰åŒã˜ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¢ã™
                const newProblem = state.problems.find(p => 
                    p.answer === preserved.answer && 
                    p.startIndex === preserved.startIndex
                );
                
                if (newProblem) {
                    // ã‚»ãƒ«ã‚’å†åº¦éš ã™
                    newProblem.cells.forEach(cell => {
                        cell.classList.add('hidden');
                        cell.textContent = 'â—‹';
                        cell.dataset.problemId = newProblem.id;
                        
                        // é–“é•ãˆãŸå˜èªã‹ãƒã‚§ãƒƒã‚¯ã—ã¦èµ¤è‰²è¡¨ç¤º
                        if (isMistakenWord(newProblem.answer)) {
                            cell.classList.add('mistake');
                        }
                    });
                }
            });
        }

        // é¸æŠã—ãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸ç§»å‹•
        function moveSelectedKeyword(direction = 'right') {
            const textarea = elements.keywordTextarea;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            // é¸æŠç¯„å›²ã‹ã‚‰è¡Œã‚’ç‰¹å®š
            const lines = text.split('\n');
            let currentPos = 0;
            let selectedLine = -1;
            
            for (let i = 0; i < lines.length; i++) {
                const lineStart = currentPos;
                const lineEnd = currentPos + lines[i].length;
                
                if (start >= lineStart && start <= lineEnd) {
                    selectedLine = i;
                    break;
                }
                currentPos = lineEnd + 1; // +1 for newline
            }
            
            if (selectedLine === -1 || !lines[selectedLine].trim()) {
                alert('ç§»å‹•ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const keyword = lines[selectedLine].trim();
            
            // æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã‚’æ±ºå®š
            let fromLevel = state.currentKeywordTab;
            let toLevel;
            
            if (direction === 'right') {
                toLevel = fromLevel === 'new' ? 'learning' : 
                         fromLevel === 'learning' ? 'mastered' : null;
            } else {
                toLevel = fromLevel === 'learning' ? 'new' : 
                         fromLevel === 'mastered' ? 'learning' : null;
            }
            
            if (!toLevel) {
                alert(direction === 'right' ? 
                    'å®Œç’§ãƒ¬ãƒ™ãƒ«ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã“ã‚Œä»¥ä¸Šç§»å‹•ã§ãã¾ã›ã‚“' : 
                    'è‹¦æ‰‹ãƒ¬ãƒ™ãƒ«ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã“ã‚Œä»¥ä¸Šæˆ»ã›ã¾ã›ã‚“');
                return;
            }
            
            // ç§»å‹•å‡¦ç†
            const fromList = state.keywords[fromLevel];
            const toList = state.keywords[toLevel];
            
            // æ—¢ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (toList.includes(keyword)) {
                const toLevelName = toLevel === 'new' ? 'è‹¦æ‰‹' : 
                                   toLevel === 'learning' ? 'ç¿’å¾—ä¸­' : 'å®Œç’§';
                alert(`ã€Œ${keyword}ã€ã¯æ—¢ã«${toLevelName}ãƒªã‚¹ãƒˆã«ã‚ã‚Šã¾ã™`);
                return;
            }
            
            // ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
            const index = fromList.indexOf(keyword);
            if (index > -1) {
                fromList.splice(index, 1);
            }
            
            // ãƒªã‚¹ãƒˆã«è¿½åŠ 
            toList.push(keyword);
            
            // ä¿å­˜
            localStorage.setItem('gijutsushiKeywords_' + fromLevel, JSON.stringify(fromList));
            localStorage.setItem('gijutsushiKeywords_' + toLevel, JSON.stringify(toList));
            
            // è¡¨ç¤ºã‚’æ›´æ–°
            elements.keywordTextarea.value = fromList.join('\n');
            
            // çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
            if (state.keywordStats[keyword]) {
                state.keywordStats[keyword].correctCount = 0;
            }
            
            saveKeywordStats();
            
            // è™«é£Ÿã„çŠ¶æ…‹ã¯å¤‰æ›´ã—ãªã„ï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¨ãƒ‡ã‚£ã‚¿ã®è¡¨ç¤ºã®ã¿æ›´æ–°ï¼‰
            
            const toLevelName = toLevel === 'new' ? 'è‹¦æ‰‹' : 
                               toLevel === 'learning' ? 'ç¿’å¾—ä¸­' : 'å®Œç’§';
            alert(`ã€Œ${keyword}ã€ã‚’${toLevelName}ã«ç§»å‹•ã—ã¾ã—ãŸ`);
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çµ±è¨ˆã®ä¿å­˜
        function saveKeywordStats() {
            localStorage.setItem('gijutsushiKeywordStats', JSON.stringify(state.keywordStats));
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çµ±è¨ˆã®èª­ã¿è¾¼ã¿
        function loadKeywordStats() {
            const saved = localStorage.getItem('gijutsushiKeywordStats');
            if (saved) {
                try {
                    state.keywordStats = JSON.parse(saved);
                } catch (e) {
                    state.keywordStats = {};
                }
            }
            
            // å¿…è¦æ­£è§£æ•°ã®è¨­å®šã‚‚èª­ã¿è¾¼ã¿
            const savedCounts = localStorage.getItem('gijutsushiRequiredCounts');
            if (savedCounts) {
                try {
                    state.requiredCounts = JSON.parse(savedCounts);
                } catch (e) {
                    state.requiredCounts = { new: 3, learning: 3 };
                }
            }
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®èª­ã¿è¾¼ã¿
        async function loadKeywords() {
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
            for (const type of ['new', 'learning', 'mastered']) {
                const saved = localStorage.getItem('gijutsushiKeywords_' + type);
                if (saved) {
                    try {
                        state.keywords[type] = JSON.parse(saved);
                    } catch (e) {
                        state.keywords[type] = [];
                    }
                }
            }

            // GitHubã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã«ãªã„å ´åˆï¼‰
            try {
                for (const type of ['new', 'learning', 'mastered']) {
                    if (state.keywords[type].length === 0) {
                        const url = `https://${githubInfo.username}.github.io/${githubInfo.repo}/keyword_${type}.txt?t=${new Date().getTime()}`;
                        const response = await fetch(url, { cache: 'no-store' });
                        if (response.ok) {
                            const text = await response.text();
                            state.keywords[type] = text.split('\n').map(k => k.trim()).filter(k => k);
                            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
                            localStorage.setItem('gijutsushiKeywords_' + type, JSON.stringify(state.keywords[type]));
                        }
                    }
                }
            } catch (error) {
                console.log('GitHubã‹ã‚‰ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }

function getRandomMaskedHint(answer) {
    if (!answer || answer.length === 0) return '';
    const idx = Math.floor(Math.random() * answer.length); // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    let res = '';
    for (let i = 0; i < answer.length; i++) {
        res += (i === idx) ? answer[i] : 'â—‹';
    }
    return res + `ï¼ˆ${answer.length}æ–‡å­—ï¼‰`;
}

            
            // åˆæœŸè¡¨ç¤ºã‚’æ›´æ–°
            elements.keywordTextarea.value = state.keywords.new.join('\n');
            
            // åˆæœŸã®ãƒœã‚¿ãƒ³è¡¨ç¤ºè¨­å®š
            const moveLeftBtn = document.getElementById('moveLeftBtn');
            const moveRightBtn = document.getElementById('moveRightBtn');
            if (moveLeftBtn && moveRightBtn) {
                moveLeftBtn.style.display = 'none';
                moveRightBtn.style.display = 'block';
            }
        }

        // éŸ³éŸ¿åŠ¹æœã‚’åˆæœŸåŒ–
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('éŸ³éŸ¿åŠ¹æœã¯åˆ©ç”¨ã§ãã¾ã›ã‚“');
            }
        }

        // éŸ³é¸æŠãƒ‘ãƒãƒ«ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleSoundTest() {
            const panel = document.getElementById('sound-test-panel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // éŸ³ã®ãƒ†ã‚¹ãƒˆå†ç”Ÿ
        function testSound(type) {
            selectedSoundType = type;
            const soundNames = ['éŸ³ãªã—', 'ãƒ”ãƒ³ãƒãƒ³', 'ã‚·ãƒ³ãƒ—ãƒ«', 'ãƒ”ã‚¢ãƒ', 'æœ¨ç´', 'ãƒ‰ãƒ¬ãƒŸ', 'ãƒ“ãƒ¼ãƒ—'];
            document.getElementById('selected-sound').textContent = soundNames[type];
            
            // è¨­å®šã‚’ä¿å­˜
            saveSettingsToLocal();
            
            if (type > 0) {
                playSuccessSound();
            }
        }

        // æ­£è§£éŸ³ã‚’å†ç”Ÿï¼ˆæ–°ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        function playSuccessSound() {
            if (!audioContext || selectedSoundType === 0) return;
            
            switch (selectedSoundType) {
                case 1: // ãƒ”ãƒ³ãƒãƒ³ï¼ˆæ—¢å­˜ï¼‰
                    playPingPong();
                    break;
                case 2: // ã‚·ãƒ³ãƒ—ãƒ«
                    playSimple();
                    break;
                case 3: // ãƒ”ã‚¢ãƒ
                    playPiano();
                    break;
                case 4: // æœ¨ç´
                    playXylophone();
                    break;
                case 5: // ãƒ‰ãƒ¬ãƒŸ
                    playDoReMi();
                    break;
                case 6: // ãƒ“ãƒ¼ãƒ—
                    playBeep();
                    break;
            }
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: ãƒ”ãƒ³ãƒãƒ³ï¼ˆãã®ã¾ã¾ï¼‰
        function playPingPong() {
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(audioContext.destination);
            
            osc1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
            osc2.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
            
            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            osc1.type = 'sine';
            osc2.type = 'sine';
            
            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc1.stop(audioContext.currentTime + 0.3);
            osc2.stop(audioContext.currentTime + 0.3);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ã‚·ãƒ³ãƒ—ãƒ«
        function playSimple() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(600, audioContext.currentTime);
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0.08, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.2);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: ãƒ”ã‚¢ãƒé¢¨
        function playPiano() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
            osc.type = 'triangle';
            
            gain.gain.setValueAtTime(0.12, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.4);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³4: æœ¨ç´é¢¨
        function playXylophone() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(1046.5, audioContext.currentTime); // C6
            osc.type = 'square';
            
            gain.gain.setValueAtTime(0.06, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.15);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³5: ãƒ‰ãƒ¬ãƒŸ
        function playDoReMi() {
            const frequencies = [523.25, 587.33, 659.25]; // C-D-E
            frequencies.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.08);
                osc.type = 'sine';
                
                gain.gain.setValueAtTime(0.06, audioContext.currentTime + i * 0.08);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.08 + 0.12);
                
                osc.start(audioContext.currentTime + i * 0.08);
                osc.stop(audioContext.currentTime + i * 0.08 + 0.12);
            });
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³6: ãƒ“ãƒ¼ãƒ—
        function playBeep() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.1);
        }

        // æ–‡å­—ãŒåŠè§’è‹±æ•°å­—ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        function isHalfWidth(char) {
            return /^[a-zA-Z0-9]$/.test(char);
        }

        // å¥èª­ç‚¹ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        function isPunctuation(char) {
            return /^[ã€ã€‚]$/.test(char);
        }

        // åˆæœŸåŒ–
        function initialize() {
            bindEvents();
            initSpeech();
            initAudio();
            loadTextList();
            loadSavedText();
            loadSavedSettings();
            loadMistakeLog();
            loadKeywords(); // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿
            loadKeywordStats(); // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çµ±è¨ˆã‚’èª­ã¿è¾¼ã¿
            initializeGrid();
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
        function bindEvents() {
            elements.textInput.addEventListener('input', debounce(handleTextInput, 500));
            elements.pageCountSelect.addEventListener('change', () => {
                initializeGrid();
                saveSettingsToLocal();
            });
            
            elements.speechRateSlider.addEventListener('input', () => {
                state.speechRate = parseFloat(elements.speechRateSlider.value);
                elements.speechRateValue.textContent = state.speechRate.toFixed(1);
                saveSettingsToLocal();
            });
            
            elements.textSelect.addEventListener('change', (e) => loadTextContent(e.target.value));
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚¤ãƒ™ãƒ³ãƒˆ
            elements.keywordNew.addEventListener('change', () => {
                updateManuscript();
                saveSettingsToLocal();
            });
            elements.keywordLearning.addEventListener('change', () => {
                updateManuscript();
                saveSettingsToLocal();
            });
            elements.keywordMastered.addEventListener('change', () => {
                updateManuscript();
                saveSettingsToLocal();
            });
            
            elements.playPauseBtn.addEventListener('click', togglePlay);
            elements.speedSlider.addEventListener('input', updateSpeed);
            elements.speechToggle.addEventListener('change', saveSettingsToLocal);
            elements.autopauseToggle.addEventListener('change', saveSettingsToLocal);
            
            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—é–¢é€£
            elements.submitBtn.addEventListener('click', submitAnswer);
            elements.cancelBtn.addEventListener('click', hidePopup);
            elements.showAnswerBtn.addEventListener('click', showAnswer);
            elements.popupInput.addEventListener('keydown', handlePopupKeydown);
            
            // å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
            document.addEventListener('click', (e) => {
                if (!elements.popupEditor.contains(e.target) && !e.target.closest('.cell')) {
                    hidePopup();
                }
            });
        }

        // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
        function initializeGrid() {
            const pageCount = parseInt(elements.pageCountSelect.value);
            const totalCells = pageCount * 600;
            elements.maxChars.textContent = totalCells;
            
            elements.manuscriptPaper.innerHTML = '';
            
            for (let pageNum = 0; pageNum < pageCount; pageNum++) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'page';
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'grid';
                
                for (let i = 0; i < 600; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.addEventListener('click', handleCellClick);
                    gridDiv.appendChild(cell);
                }
                
                const pageNumber = document.createElement('div');
                pageNumber.className = 'page-number';
                pageNumber.textContent = `${pageNum + 1}/${pageCount}`;
                
                pageDiv.appendChild(gridDiv);
                pageDiv.appendChild(pageNumber);
                elements.manuscriptPaper.appendChild(pageDiv);
            }
            
            updateManuscript();
        }

        // æ–‡ç« æ›´æ–°å‡¦ç†
        function updateManuscript() {
            pause();
            hidePopup();
            state.currentWordIndex = -1;
            state.problems = [];
            state.characterData = [];
            
            const text = elements.textInput.value;
            const allCells = Array.from(elements.manuscriptPaper.querySelectorAll('.cell'));
            
            // ã‚»ãƒ«ã‚’ã‚¯ãƒªã‚¢
            allCells.forEach(cell => {
                cell.textContent = '';
                cell.className = 'cell';
                const endPunc = cell.querySelector('.end-punctuation');
                if (endPunc) endPunc.remove();
                delete cell.dataset.charIndex;
                delete cell.dataset.problemId;
            });

            if (!text.trim()) {
                elements.charCount.textContent = '0';
                return;
            }

            // æ–‡å­—é…ç½®å‡¦ç†
            let cellIndex = 0;
            let textIndex = 0;
            let charCount = 0;

            while (textIndex < text.length && cellIndex < allCells.length) {
                const char = text[textIndex];
                const currentCol = (cellIndex % 600) % 24;

                if (char === '\n') {
                    // æ”¹è¡Œå‡¦ç†
                    if (cellIndex > 0 && cellIndex % 24 === 0) {
                        textIndex++;
                        continue;
                    }
                    const currentPageRow = Math.floor((cellIndex % 600) / 24);
                    cellIndex = Math.floor(cellIndex / 600) * 600 + (currentPageRow + 1) * 24;
                    textIndex++;
                    continue;
                }

                // å¥èª­ç‚¹å‡¦ç†
                const nextChar = textIndex + 1 < text.length ? text[textIndex + 1] : null;
                
                if (currentCol === 23 && nextChar && isPunctuation(nextChar)) {
                    allCells[cellIndex].textContent = char;
                    allCells[cellIndex].dataset.charIndex = textIndex;
                    state.characterData[textIndex] = {
                        char: char,
                        cell: allCells[cellIndex],
                        cellIndex: cellIndex
                    };
                    
                    const punctuationSpan = document.createElement('span');
                    punctuationSpan.className = 'end-punctuation';
                    punctuationSpan.textContent = nextChar;
                    allCells[cellIndex].appendChild(punctuationSpan);
                    allCells[cellIndex].classList.add('punctuation');
                    
                    textIndex += 2;
                    charCount += 2;
                    cellIndex = Math.floor(cellIndex / 24) * 24 + 24;
                    continue;
                }

                // åŠè§’è‹±æ•°å­—ã®é€£ç¶šå‡¦ç†
                if (isHalfWidth(char) && nextChar && isHalfWidth(nextChar)) {
                    allCells[cellIndex].textContent = char + nextChar;
                    allCells[cellIndex].classList.add('half-width');
                    allCells[cellIndex].dataset.charIndex = textIndex;
                    
                    // ä¸¡æ–¹ã®æ–‡å­—ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                    state.characterData[textIndex] = {
                        char: char,
                        cell: allCells[cellIndex],
                        cellIndex: cellIndex,
                        isFirstHalf: true
                    };
                    state.characterData[textIndex + 1] = {
                        char: nextChar,
                        cell: allCells[cellIndex],
                        cellIndex: cellIndex,
                        isSecondHalf: true
                    };
                    
                    textIndex += 2;
                    charCount += 2;
                    cellIndex++;
                    continue;
                }

                // é€šå¸¸æ–‡å­—é…ç½®
                allCells[cellIndex].textContent = char;
                allCells[cellIndex].dataset.charIndex = textIndex;
                state.characterData[textIndex] = {
                    char: char,
                    cell: allCells[cellIndex],
                    cellIndex: cellIndex
                };
                
                if (isPunctuation(char)) {
                    allCells[cellIndex].classList.add('punctuation');
                }
                
                textIndex++;
                charCount++;
                cellIndex++;
            }

            elements.charCount.textContent = charCount;
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è™«é£Ÿã„å•é¡Œç”Ÿæˆ
            generateKeywordProblems(text);
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è™«é£Ÿã„å•é¡Œç”Ÿæˆ
        function generateKeywordProblems(text) {
            const activeKeywords = [];
            
            // ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’åé›†
            if (elements.keywordNew.checked) {
                activeKeywords.push(...state.keywords.new);
            }
            if (elements.keywordLearning.checked) {
                activeKeywords.push(...state.keywords.learning);
            }
            if (elements.keywordMastered.checked) {
                activeKeywords.push(...state.keywords.mastered);
            }
            
            if (activeKeywords.length === 0) return;
            
            // é‡è¤‡ã‚’å‰Šé™¤ã—ã¦ã‚½ãƒ¼ãƒˆï¼ˆé•·ã„é †ï¼‰
            const uniqueKeywords = [...new Set(activeKeywords)].sort((a, b) => b.length - a.length);
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢ã—ã¦å•é¡Œã‚’ä½œæˆ
            const foundProblems = [];
            
            uniqueKeywords.forEach(keyword => {
                let searchStart = 0;
                while (true) {
                    const index = text.indexOf(keyword, searchStart);
                    if (index === -1) break;
                    
                    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    let overlaps = false;
                    for (const existing of foundProblems) {
                        if ((index >= existing.start && index < existing.end) ||
                            (index + keyword.length > existing.start && index + keyword.length <= existing.end)) {
                            overlaps = true;
                            break;
                        }
                    }
                    
                    if (!overlaps) {
                        foundProblems.push({
                            keyword: keyword,
                            start: index,
                            end: index + keyword.length
                        });
                    }
                    
                    searchStart = index + 1;
                }
            });
            
            // é–‹å§‹ä½ç½®ã§ã‚½ãƒ¼ãƒˆ
            foundProblems.sort((a, b) => a.start - b.start);
            
            // å•é¡Œã‚’ä½œæˆ
            foundProblems.forEach((found, index) => {
                const cells = [];
                
                // è©²å½“ã™ã‚‹æ–‡å­—ã®ã‚»ãƒ«ã‚’å–å¾—
                for (let i = found.start; i < found.end; i++) {
                    const charData = state.characterData[i];
                    if (charData && charData.cell) {
                        cells.push(charData.cell);
                    }
                }
                
                if (cells.length > 0) {
                    const problem = {
                        id: index,
                        startIndex: found.start,
                        endIndex: found.end - 1,
                        answer: found.keyword,
                        cells: cells
                    };
                    
                    state.problems.push(problem);
                    console.log('ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è™«é£Ÿã„å•é¡Œä½œæˆ:', problem.answer);
                    
                    // ã‚»ãƒ«ã‚’éš ã™
                    cells.forEach(cell => {
                        cell.classList.add('hidden');
                        cell.textContent = 'â—‹';
                        cell.dataset.problemId = problem.id;
                        
                        // é–“é•ãˆãŸå˜èªã‹ãƒã‚§ãƒƒã‚¯ã—ã¦èµ¤è‰²è¡¨ç¤º
                        if (isMistakenWord(problem.answer)) {
                            cell.classList.add('mistake');
                        }
                    });
                }
            });
        }

        // ã‚»ãƒ«ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleCellClick(event) {
            const cell = event.target;
            if (!cell.classList.contains('hidden') || !cell.dataset.problemId) return;

            const problemId = parseInt(cell.dataset.problemId);
            const problem = state.problems[problemId];
            if (!problem) return;

            state.currentEditingProblem = problem;
            state.currentEditingProblemIndex = problemId; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨˜éŒ²
            showPopup(problem);
        }

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º
        function showPopup(problem) {
            const answer = problem.answer;
            
            // ç¾åœ¨ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ¬ãƒ™ãƒ«ã‚’åˆ¤å®š
            let currentLevel = null;
            let levelName = '';
            let levelColor = '';
            
            if (state.keywords.new.includes(answer)) {
                currentLevel = 'new';
                levelName = 'âŒ è‹¦æ‰‹';
                levelColor = '#dc3545';
            } else if (state.keywords.learning.includes(answer)) {
                currentLevel = 'learning';
                levelName = 'â“ ç¿’å¾—ä¸­';
                levelColor = '#ffc107';
            } else if (state.keywords.mastered.includes(answer)) {
                currentLevel = 'mastered';
                levelName = 'â­• å®Œç’§';
                levelColor = '#28a745';
            }
            
            // ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
            const levelDisplay = document.getElementById('current-level');
            if (levelDisplay) {
                levelDisplay.textContent = levelName;
                levelDisplay.style.color = levelColor;
            }
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æƒ…å ±ã‚’è¡¨ç¤º
            //document.getElementById('keyword-display').textContent = `ã€Œ${answer}ã€`;
            document.getElementById('keyword-length').textContent = getRandomMaskedHint(answer);
            document.getElementById('keyword-length').textContent = `ï¼ˆ${answer.length}æ–‡å­—ï¼‰`;
            // ä½¿ã„æ–¹ä¾‹
            // çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º
            const stats = state.keywordStats[answer] || { correctCount: 0 };
            const mistakeCount = state.mistakeLog.filter(m => m.word === answer).reduce((sum, m) => sum + (m.count || 1), 0);
            const requiredCount = getRequiredCount(currentLevel);
            
            document.getElementById('correct-count').textContent = `æ­£è§£: ${stats.correctCount}/${requiredCount}å›ç›®`;
            document.getElementById('mistake-count').textContent = mistakeCount > 0 ? `é–“é•ã„: ${mistakeCount}å›` : '';
            
            // å¿…è¦æ­£è§£æ•°ã®é¸æŠçŠ¶æ…‹ã‚’è¨­å®š
            const requiredSelect = document.getElementById('required-correct-count');
            if (requiredSelect) {
                requiredSelect.value = requiredCount.toString();
            }
            
            // èª­ã¿ä¸Šã’æ©Ÿèƒ½
            if (elements.speechToggle.checked) {
                if (state.slowMode) {
                    speakSlowly(answer);
                } else {
                    const utterance = new SpeechSynthesisUtterance(answer);
                    utterance.rate = state.speechRate;
                    utterance.lang = 'ja-JP';
                    if (state.voices.length > 0) {
                        utterance.voice = state.voices[0];
                    }
                    speechSynthesis.speak(utterance);
                }
            }
            
            elements.popupInput.value = '';
            elements.popupInput.style.width = `${Math.max(problem.answer.length + 5, 6)}em`;
            elements.feedbackMessage.textContent = '';
            elements.feedbackMessage.className = '';

            // å•é¡Œã®ã‚»ãƒ«ã‚’ç·¨é›†çŠ¶æ…‹ã«
            problem.cells.forEach(cell => cell.classList.add('editing'));

            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ä½ç½®èª¿æ•´
            const firstCell = problem.cells[0];
            const rect = firstCell.getBoundingClientRect();
            elements.popupEditor.style.display = 'block';
            elements.popupEditor.style.top = `${window.scrollY + rect.top - elements.popupEditor.offsetHeight - 10}px`;
            elements.popupEditor.style.left = `${window.scrollX + rect.left + (rect.width / 2) - (elements.popupEditor.offsetWidth / 2)}px`;
            
            elements.popupInput.focus();
        }

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—éè¡¨ç¤º
        function hidePopup() {
            document.querySelectorAll('.cell.editing').forEach(cell => {
                cell.classList.remove('editing');
            });
            elements.popupEditor.style.display = 'none';
            elements.popupEditor.classList.remove('incorrect-feedback');
            state.currentEditingProblem = null;
            state.currentEditingProblemIndex = -1;
        }

        // æ¬¡ã®è™«é£Ÿã„å•é¡Œã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
        function findNextHiddenProblem() {
            // ç¾åœ¨ç·¨é›†ä¸­ã®å•é¡Œã‚ˆã‚Šå¾Œã«ã‚ã‚‹ã€ã¾ã éš ã•ã‚Œã¦ã„ã‚‹å•é¡Œã‚’æ¢ã™
            let foundCurrent = false;
            
            for (let i = 0; i < state.problems.length; i++) {
                const problem = state.problems[i];
                
                // ç¾åœ¨ã®å•é¡Œã‚’è¦‹ã¤ã‘ãŸå¾Œã®å•é¡Œã‚’æ¢ã™
                if (foundCurrent) {
                    const hasHiddenCells = problem.cells.some(cell => cell.classList.contains('hidden'));
                    if (hasHiddenCells) {
                        console.log('æ¬¡ã®å•é¡Œã‚’ç™ºè¦‹:', problem.answer);
                        return problem;
                    }
                }
                
                // ç¾åœ¨ç·¨é›†ä¸­ã®å•é¡Œã‹ãƒã‚§ãƒƒã‚¯
                if (state.currentEditingProblem && problem.id === state.currentEditingProblem.id) {
                    foundCurrent = true;
                }
            }
            
            console.log('æ¬¡ã®å•é¡Œãªã—');
            return null;
        }

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‹ã‚‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ¬ãƒ™ãƒ«ã‚’å¤‰æ›´
        function moveKeywordToLevel(targetLevel) {
            if (!state.currentEditingProblem) return;
            
            const keyword = state.currentEditingProblem.answer;
            
            // ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã‚’ç‰¹å®š
            let currentLevel = null;
            if (state.keywords.new.includes(keyword)) {
                currentLevel = 'new';
            } else if (state.keywords.learning.includes(keyword)) {
                currentLevel = 'learning';
            } else if (state.keywords.mastered.includes(keyword)) {
                currentLevel = 'mastered';
            }
            
            if (!currentLevel || currentLevel === targetLevel) {
                if (currentLevel === targetLevel) {
                    alert('æ—¢ã«åŒã˜ãƒ¬ãƒ™ãƒ«ã§ã™');
                }
                return;
            }
            
            // ç§»å‹•å‡¦ç†
            const fromList = state.keywords[currentLevel];
            const toList = state.keywords[targetLevel];
            
            // ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
            const index = fromList.indexOf(keyword);
            if (index > -1) {
                fromList.splice(index, 1);
            }
            
            // ãƒªã‚¹ãƒˆã«è¿½åŠ 
            if (!toList.includes(keyword)) {
                toList.push(keyword);
            }
            
            // ä¿å­˜
            localStorage.setItem('gijutsushiKeywords_' + currentLevel, JSON.stringify(fromList));
            localStorage.setItem('gijutsushiKeywords_' + targetLevel, JSON.stringify(toList));
            
            // çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
            if (state.keywordStats[keyword]) {
                state.keywordStats[keyword].correctCount = 0;
            }
            saveKeywordStats();
            
            // ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
            const levelNames = {
                'new': 'âŒ è‹¦æ‰‹',
                'learning': 'â“ ç¿’å¾—ä¸­',
                'mastered': 'â­• å®Œç’§'
            };
            const levelColors = {
                'new': '#dc3545',
                'learning': '#ffc107',
                'mastered': '#28a745'
            };
            
            const levelDisplay = document.getElementById('current-level');
            if (levelDisplay) {
                levelDisplay.textContent = levelNames[targetLevel];
                levelDisplay.style.color = levelColors[targetLevel];
            }
            
            // å®Œç’§ã«ç§»å‹•ã—ãŸå ´åˆã¯æ­£è§£æ‰±ã„ã«ã—ã¦æ¬¡ã¸
            if (targetLevel === 'mastered') {
                // æ­£è§£éŸ³ã‚’å†ç”Ÿ
                playSuccessSound();
                
                // ã‚»ãƒ«ã‚’è¡¨ç¤º
                state.currentEditingProblem.cells.forEach(cell => {
                    cell.classList.remove('hidden', 'editing');
                    cell.classList.add('correct');
                    const charIndex = parseInt(cell.dataset.charIndex);
                    const charData = state.characterData[charIndex];
                    if (charData) {
                        cell.textContent = charData.char;
                    }
                });
                
                // æ¬¡ã®å•é¡Œã¸
                const nextProblem = findNextHiddenProblem();
                hidePopup();
                
                setTimeout(() => {
                    if (nextProblem) {
                        state.currentEditingProblem = nextProblem;
                        state.currentEditingProblemIndex = nextProblem.id;
                        showPopup(nextProblem);
                    } else if (elements.autopauseToggle.checked && !state.isPlaying) {
                        setTimeout(() => {
                            play();
                        }, 500);
                    }
                }, 300);
            }
        }

        // ç­”ãˆç¢ºèª
        function submitAnswer() {
            if (!state.currentEditingProblem) return;

            const userAnswer = elements.popupInput.value.trim();
            const correctAnswer = state.currentEditingProblem.answer;

            if (userAnswer === correctAnswer) {
                console.log('æ­£è§£ï¼æ¬¡ã®å•é¡Œã‚’æ¢ã—ã¾ã™...');
                
                // æ­£è§£éŸ³ã‚’å†ç”Ÿ
                playSuccessSound();
                
                // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çµ±è¨ˆã‚’æ›´æ–°
                updateKeywordStats(correctAnswer);
                
                // æ¬¡ã®å•é¡Œã‚’å…ˆã«æ¢ã™ï¼ˆhidePopupå‰ã«ï¼‰
                const nextProblem = findNextHiddenProblem();
                
                // æ­£è§£å‡¦ç†
                state.currentEditingProblem.cells.forEach(cell => {
                    cell.classList.remove('hidden', 'editing');
                    cell.classList.add('correct');
                    const charIndex = parseInt(cell.dataset.charIndex);
                    const charData = state.characterData[charIndex];
                    if (charData) {
                        cell.textContent = charData.char;
                    }
                });
                hidePopup();
                
                // æ¬¡ã®è™«é£Ÿã„å•é¡Œã‚’è‡ªå‹•ã§è¡¨ç¤º
                setTimeout(() => {
                    if (nextProblem) {
                        console.log('æ¬¡ã®å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ:', nextProblem.answer);
                        // æ¬¡ã®å•é¡ŒãŒã‚ã‚Œã°è‡ªå‹•ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—
                        state.currentEditingProblem = nextProblem;
                        state.currentEditingProblemIndex = nextProblem.id;
                        showPopup(nextProblem);
                    } else {
                        console.log('æ¬¡ã®å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        if (elements.autopauseToggle.checked && !state.isPlaying) {
                            // å…¨ã¦ã®å•é¡ŒãŒè§£æ±ºã•ã‚Œã¦ã€ã‹ã¤å†ç”Ÿåœæ­¢ä¸­ãªã‚‰å†ç”Ÿã‚’ç¶™ç¶š
                            setTimeout(() => {
                                play();
                            }, 500);
                        }
                    }
                }, 300);
                
            } else {
                // ä¸æ­£è§£ - é–“é•ã„ã‚’è¨˜éŒ²
                const wrongWord = state.currentEditingProblem.answer;
                recordMistake(wrongWord, userAnswer, correctAnswer);
                
                elements.feedbackMessage.textContent = `ä¸æ­£è§£ã§ã™ã€‚æ­£è§£ã¯ã€Œ${correctAnswer}ã€`;
                elements.feedbackMessage.className = 'error';
                elements.popupEditor.classList.add('incorrect-feedback');
                elements.popupInput.select();
                
                setTimeout(() => {
                    elements.popupEditor.classList.remove('incorrect-feedback');
                }, 500);
            }
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çµ±è¨ˆã‚’æ›´æ–°
        function updateKeywordStats(keyword) {
            // çµ±è¨ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãªã‘ã‚Œã°ä½œæˆ
            if (!state.keywordStats[keyword]) {
                state.keywordStats[keyword] = {
                    correctCount: 0,
                    lastCorrect: null
                };
            }
            
            // æ­£è§£å›æ•°ã‚’å¢—ã‚„ã™
            state.keywordStats[keyword].correctCount++;
            state.keywordStats[keyword].lastCorrect = new Date().toISOString();
            
            saveKeywordStats();
            
            // è‡ªå‹•ç§»å‹•ã®ãƒã‚§ãƒƒã‚¯
            const correctCount = state.keywordStats[keyword].correctCount;
            
            // ã©ã®ãƒªã‚¹ãƒˆã«å±ã—ã¦ã„ã‚‹ã‹ç¢ºèª
            let currentLevel = null;
            if (state.keywords.new.includes(keyword)) {
                currentLevel = 'new';
            } else if (state.keywords.learning.includes(keyword)) {
                currentLevel = 'learning';
            } else if (state.keywords.mastered.includes(keyword)) {
                currentLevel = 'mastered';
            }
            
            // è‡ªå‹•ç§»å‹•ã®æ¡ä»¶ï¼ˆå‹•çš„ãªå¿…è¦æ­£è§£æ•°ã‚’ä½¿ç”¨ï¼‰
            const shouldMove = (currentLevel === 'new' && correctCount >= state.requiredCounts.new) ||
                              (currentLevel === 'learning' && correctCount >= state.requiredCounts.learning);
            
            if (shouldMove && currentLevel !== 'mastered') {
                autoMoveKeyword(keyword, currentLevel);
            }
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è‡ªå‹•ç§»å‹•
        function autoMoveKeyword(keyword, fromLevel) {
            const toLevel = fromLevel === 'new' ? 'learning' : 'mastered';
            
            // ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
            const index = state.keywords[fromLevel].indexOf(keyword);
            if (index > -1) {
                state.keywords[fromLevel].splice(index, 1);
            }
            
            // ãƒªã‚¹ãƒˆã«è¿½åŠ 
            if (!state.keywords[toLevel].includes(keyword)) {
                state.keywords[toLevel].push(keyword);
            }
            
            // ä¿å­˜
            localStorage.setItem('gijutsushiKeywords_' + fromLevel, JSON.stringify(state.keywords[fromLevel]));
            localStorage.setItem('gijutsushiKeywords_' + toLevel, JSON.stringify(state.keywords[toLevel]));
            
            // çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
            state.keywordStats[keyword].correctCount = 0;
            saveKeywordStats();
            
            // é€šçŸ¥
            const toLevelName = toLevel === 'learning' ? 'ç¿’å¾—ä¸­' : 'å®Œç’§';
            alert(`ğŸ‰ã€Œ${keyword}ã€ã‚’ãƒã‚¹ã‚¿ãƒ¼ï¼${toLevelName}ãƒ¬ãƒ™ãƒ«ã«ç§»å‹•ã—ã¾ã—ãŸ`);
            
            // è™«é£Ÿã„çŠ¶æ…‹ã¯å¤‰æ›´ã—ãªã„ï¼ˆç”»é¢æ›´æ–°ãªã—ï¼‰
        }

        // ç­”ãˆã‚’è¦‹ã‚‹
        function showAnswer() {
            if (!state.currentEditingProblem) return;
            
            const correctAnswer = state.currentEditingProblem.answer;
            elements.popupInput.value = correctAnswer;
            submitAnswer();
        }

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‡¦ç†
        function handlePopupKeydown(event) {
            if (event.key === 'Enter') {
                submitAnswer();
            } else if (event.key === 'Escape') {
                hidePopup();
            }
        }

        // å†ç”Ÿé–¢é€£
        function togglePlay() {
            state.isPlaying ? pause() : play();
        }

        function play() {
            if (!elements.textInput.value.trim()) return;
            
            state.isPlaying = true;
            elements.playPauseBtn.textContent = 'ä¸€æ™‚åœæ­¢';
            
            if (state.currentWordIndex >= getWordCount() - 1) {
                state.currentWordIndex = -1;
            }
            
            tick();
        }

        function pause() {
            state.isPlaying = false;
            elements.playPauseBtn.textContent = 'å†ç”Ÿ';
            clearTimeout(state.timer);
        }

        function tick() {
            if (!state.isPlaying) return;

            // å‰ã®å˜èªã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
            if (state.currentWordIndex >= 0) {
                removeWordHighlight(state.currentWordIndex);
            }

            state.currentWordIndex++;
            const wordCount = getWordCount();
            
            if (state.currentWordIndex >= wordCount) {
                pause();
                return;
            }

            // ç¾åœ¨ã®å˜èªã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            highlightWord(state.currentWordIndex);

            // éŸ³å£°èª­ã¿ä¸Šã’
            if (elements.speechToggle.checked) {
                speakCurrentWord();
            }

            // è™«é£Ÿã„éƒ¨åˆ†ã§ä¸€æ™‚åœæ­¢ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (elements.autopauseToggle.checked && isWordHidden(state.currentWordIndex)) {
                pause();
                
                // èª­ã¿ä¸Šã’ONã®å ´åˆã¯è‡ªå‹•ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º
                if (elements.speechToggle.checked) {
                    setTimeout(() => {
                        const wordCells = getWordCells(state.currentWordIndex);
                        if (wordCells.length > 0) {
                            handleCellClick({ target: wordCells[0] });
                        }
                    }, 1000); // èª­ã¿ä¸Šã’å®Œäº†ã‚’å¾…ã¤
                } else {
                    // èª­ã¿ä¸Šã’OFFã®å ´åˆã¯å¾“æ¥é€šã‚Š
                    const wordCells = getWordCells(state.currentWordIndex);
                    if (wordCells.length > 0) {
                        handleCellClick({ target: wordCells[0] });
                    }
                }
            } else {
                state.timer = setTimeout(tick, state.speed);
            }
        }

        function getWordCount() {
            const text = elements.textInput.value;
            const words = text.match(/[\p{L}\p{N}]+|[ã€ã€‚]/gu) || [];
            return words.length;
        }

        function highlightWord(wordIndex) {
            const cells = getWordCells(wordIndex);
            cells.forEach(cell => cell.classList.add('highlight'));
        }

        function removeWordHighlight(wordIndex) {
            const cells = getWordCells(wordIndex);
            cells.forEach(cell => cell.classList.remove('highlight'));
        }

        function getWordCells(wordIndex) {
            const text = elements.textInput.value;
            const words = text.match(/[\p{L}\p{N}]+|[ã€ã€‚]/gu) || [];
            
            if (wordIndex >= words.length) return [];
            
            // å˜èªã®ä½ç½®ã‚’è¨ˆç®—
            let charPosition = 0;
            for (let i = 0; i < wordIndex; i++) {
                const wordStart = text.indexOf(words[i], charPosition);
                charPosition = wordStart + words[i].length;
            }
            
            const targetWord = words[wordIndex];
            const wordStart = text.indexOf(targetWord, charPosition);
            const wordEnd = wordStart + targetWord.length;
            
            const cells = [];
            for (let i = wordStart; i < wordEnd; i++) {
                const charData = state.characterData[i];
                if (charData && charData.cell) {
                    cells.push(charData.cell);
                }
            }
            
            return cells;
        }

        function isWordHidden(wordIndex) {
            const cells = getWordCells(wordIndex);
            return cells.some(cell => cell.classList.contains('hidden'));
        }

        function speakCurrentWord() {
            if (!('speechSynthesis' in window)) return;
            
            const text = elements.textInput.value;
            const words = text.match(/[\p{L}\p{N}]+|[ã€ã€‚]/gu) || [];
            
            if (state.currentWordIndex < words.length) {
                const word = words[state.currentWordIndex];
                const utterance = new SpeechSynthesisUtterance(word);

                utterance.rate = state.speechRate; // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§è¨­å®šã—ãŸé€Ÿåº¦ã‚’é©ç”¨
                
                utterance.lang = 'ja-JP';
                
                if (state.voices.length > 0) {
                    utterance.voice = state.voices[0];
                }
                
                speechSynthesis.speak(utterance);
            }
        }

        // ãã®ä»–ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function updateSpeed() {
            state.speed = parseFloat(elements.speedSlider.value) * 1000;
            elements.speedValue.textContent = elements.speedSlider.value;
            saveSettingsToLocal();
        }

        function initSpeech() {
            if ('speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = () => {
                    state.voices = speechSynthesis.getVoices().filter(voice => voice.lang === 'ja-JP');
                };
            } else {
                elements.speechToggle.parentElement.style.display = 'none';
            }
        }

        function handleTextInput() {
            updateManuscript();
            saveTextToLocal();
        }

        function saveTextToLocal() {
            localStorage.setItem('gijutsushiText_integrated', elements.textInput.value);
        }

        function saveSettingsToLocal() {
            const settings = {
                speed: elements.speedSlider.value,
                speechEnabled: elements.speechToggle.checked,
                autopauseEnabled: elements.autopauseToggle.checked,
                soundType: selectedSoundType,
                speechRate: state.speechRate,
                pageCount: elements.pageCountSelect.value,
                keywordNew: elements.keywordNew.checked,
                keywordLearning: elements.keywordLearning.checked,
                keywordMastered: elements.keywordMastered.checked
            };
            localStorage.setItem('gijutsushiSettings_integrated', JSON.stringify(settings));
        }

        // é–“é•ã„ãƒ­ã‚°ã®ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿
        function saveMistakeLog() {
            localStorage.setItem('gijutsushiMistakes_integrated', JSON.stringify(state.mistakeLog));
        }

        function loadMistakeLog() {
            const savedMistakes = localStorage.getItem('gijutsushiMistakes_integrated');
            if (savedMistakes) {
                try {
                    state.mistakeLog = JSON.parse(savedMistakes);
                } catch (error) {
                    console.error('é–“é•ã„ãƒ­ã‚°èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    state.mistakeLog = [];
                }
            }
        }

        // é–“é•ã„ã‚’è¨˜éŒ²ã™ã‚‹
        function recordMistake(word, userAnswer, correctAnswer) {
            const now = new Date();
            const mistake = {
                word: word,
                userAnswer: userAnswer,
                correctAnswer: correctAnswer,
                timestamp: now.toISOString(),
                date: now.toLocaleDateString('ja-JP')
            };

            // æ—¢å­˜ã®é–“é•ã„ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const existingIndex = state.mistakeLog.findIndex(m => m.word === word);
            if (existingIndex !== -1) {
                // æ—¢å­˜ã®é–“é•ã„ã«è¿½åŠ 
                if (!state.mistakeLog[existingIndex].attempts) {
                    state.mistakeLog[existingIndex].attempts = [];
                }
                state.mistakeLog[existingIndex].attempts.push(mistake);
                state.mistakeLog[existingIndex].count = (state.mistakeLog[existingIndex].count || 1) + 1;
                state.mistakeLog[existingIndex].lastMistake = now.toISOString();
            } else {
                // æ–°ã—ã„é–“é•ã„ã¨ã—ã¦è¿½åŠ 
                state.mistakeLog.push({
                    word: word,
                    userAnswer: userAnswer,
                    correctAnswer: correctAnswer,
                    count: 1,
                    firstMistake: now.toISOString(),
                    lastMistake: now.toISOString(),
                    attempts: [mistake]
                });
            }

            saveMistakeLog();
            console.log('é–“é•ã„ã‚’è¨˜éŒ²ã—ã¾ã—ãŸ:', word);
        }

        // å˜èªãŒéå»ã«é–“é•ãˆã‚‰ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯
        function isMistakenWord(word) {
            return state.mistakeLog.some(m => m.word === word);
        }

        // é–“é•ã„ãƒ­ã‚°ãƒ‘ãƒãƒ«ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleMistakeLog() {
            const panel = document.getElementById('mistake-log-panel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                updateMistakeLogDisplay();
            } else {
                panel.style.display = 'none';
            }
        }

        // é–“é•ã„ãƒ­ã‚°ã®è¡¨ç¤ºæ›´æ–°
        function updateMistakeLogDisplay() {
            const listElement = document.getElementById('mistake-list');
            if (state.mistakeLog.length === 0) {
                listElement.innerHTML = '<p style="color: #28a745;">ã¾ã é–“é•ã„ã¯ã‚ã‚Šã¾ã›ã‚“ï¼</p>';
                return;
            }

            // é–“é•ã„å›æ•°ã®å¤šã„é †ã«ã‚½ãƒ¼ãƒˆ
            const sortedMistakes = [...state.mistakeLog].sort((a, b) => b.count - a.count);
            
            listElement.innerHTML = sortedMistakes.map(mistake => `
                <div style="background-color: white; padding: 8px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #dc3545;">
                    <strong>${mistake.word}</strong> 
                    <span style="color: #dc3545;">(${mistake.count}å›é–“é•ã„)</span>
                    <br>
                    <small style="color: #666;">æœ€å¾Œã®é–“é•ã„: ${new Date(mistake.lastMistake).toLocaleString('ja-JP')}</small>
                </div>
            `).join('');
        }

        // é–“é•ã„ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢
        function clearMistakeLog() {
            if (confirm('é–“é•ã„ãƒ­ã‚°ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                state.mistakeLog = [];
                saveMistakeLog();
                updateMistakeLogDisplay();
                updateManuscript(); // èµ¤è‰²è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
                console.log('é–“é•ã„ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
            }
        }

        // è‹¦æ‰‹å•é¡Œã®ã¿ãƒ¢ãƒ¼ãƒ‰
        function mistakeOnlyMode() {
            if (state.mistakeLog.length === 0) {
                alert('é–“é•ã„ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            alert('è‹¦æ‰‹å•é¡Œã®ã¿ãƒ¢ãƒ¼ãƒ‰ï¼ˆæœªå®Ÿè£…ï¼‰\né–“é•ãˆãŸå˜èªã®ã¿ã‚’è™«é£Ÿã„è¡¨ç¤ºã™ã‚‹æ©Ÿèƒ½ã§ã™');
            // TODO: å®Ÿè£…äºˆå®š
        }

        function loadSavedText() {
            const saved = localStorage.getItem('gijutsushiText_integrated');
            if (saved) {
                elements.textInput.value = saved;
            }
        }

        function loadSavedSettings() {
            const savedSettings = localStorage.getItem('gijutsushiSettings_integrated');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    
                    if (settings.speechRate !== undefined) {
                        elements.speechRateSlider.value = settings.speechRate;
                        state.speechRate = settings.speechRate;
                        elements.speechRateValue.textContent = settings.speechRate.toFixed(1);
                    }
                    
                    // é€Ÿåº¦è¨­å®šã‚’å¾©å…ƒ
                    if (settings.speed) {
                        elements.speedSlider.value = settings.speed;
                        state.speed = parseFloat(settings.speed) * 1000;
                        elements.speedValue.textContent = settings.speed;
                    }
                    
                    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å¾©å…ƒ
                    if (settings.speechEnabled !== undefined) {
                        elements.speechToggle.checked = settings.speechEnabled;
                    }
                    
                    if (settings.autopauseEnabled !== undefined) {
                        elements.autopauseToggle.checked = settings.autopauseEnabled;
                    }
                    
                    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å¾©å…ƒ
                    if (settings.keywordNew !== undefined) {
                        elements.keywordNew.checked = settings.keywordNew;
                    }
                    if (settings.keywordLearning !== undefined) {
                        elements.keywordLearning.checked = settings.keywordLearning;
                    }
                    if (settings.keywordMastered !== undefined) {
                        elements.keywordMastered.checked = settings.keywordMastered;
                    }
                    
                    // ãƒšãƒ¼ã‚¸æ•°ã‚’å¾©å…ƒ
                    if (settings.pageCount) {
                        elements.pageCountSelect.value = settings.pageCount;
                    }
                    
                    // éŸ³è¨­å®šã‚’å¾©å…ƒ
                    if (settings.soundType !== undefined) {
                        selectedSoundType = settings.soundType;
                        const soundNames = ['éŸ³ãªã—', 'ãƒ”ãƒ³ãƒãƒ³', 'ã‚·ãƒ³ãƒ—ãƒ«', 'ãƒ”ã‚¢ãƒ', 'æœ¨ç´', 'ãƒ‰ãƒ¬ãƒŸ', 'ãƒ“ãƒ¼ãƒ—'];
                        const soundElement = document.getElementById('selected-sound');
                        if (soundElement) {
                            soundElement.textContent = soundNames[selectedSoundType];
                        }
                    }
                } catch (error) {
                    console.error('è¨­å®šèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
        }

        async function loadTextList() {
            const url = `https://${githubInfo.username}.github.io/${githubInfo.repo}/index.json?t=${new Date().getTime()}`;
            try {
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) return;
                
                const fileList = await response.json();
                elements.textSelect.innerHTML = '<option value="">GitHubã‹ã‚‰é¸æŠ...</option>';
                
                fileList.forEach(fileName => {
                    const option = document.createElement('option');
                    option.value = fileName;
                    option.textContent = fileName.replace('.txt', '');
                    elements.textSelect.appendChild(option);
                });
            } catch (error) {
                console.error('ãƒ†ã‚­ã‚¹ãƒˆãƒªã‚¹ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        async function loadTextContent(fileName) {
            if (!fileName) return;
            
            const url = `https://${githubInfo.username}.github.io/${githubInfo.repo}/${fileName}?t=${new Date().getTime()}`;
            try {
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: ${fileName}`);
                
                const text = await response.text();
                elements.textInput.value = text;
                handleTextInput();
            } catch (error) {
                console.error('ãƒ†ã‚­ã‚¹ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                elements.textInput.value = `ã‚¨ãƒ©ãƒ¼: ${error.message}`;
            }
        }

        // å¿…è¦æ­£è§£æ•°ã‚’å–å¾—
        function getRequiredCount(level) {
            if (level === 'new') return state.requiredCounts.new;
            if (level === 'learning') return state.requiredCounts.learning;
            return 0; // å®Œç’§ãƒ¬ãƒ™ãƒ«ã¯ç§»å‹•ãªã—
        }

        // å¿…è¦æ­£è§£æ•°ã‚’æ›´æ–°
        function updateRequiredCount() {
            const select = document.getElementById('required-correct-count');
            const value = parseInt(select.value);
            
            // ç¾åœ¨ç·¨é›†ä¸­ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ãƒ¬ãƒ™ãƒ«ã‚’ç‰¹å®š
            if (state.currentEditingProblem) {
                const keyword = state.currentEditingProblem.answer;
                if (state.keywords.new.includes(keyword)) {
                    state.requiredCounts.new = value;
                } else if (state.keywords.learning.includes(keyword)) {
                    state.requiredCounts.learning = value;
                }
                
                // ä¿å­˜
                localStorage.setItem('gijutsushiRequiredCounts', JSON.stringify(state.requiredCounts));
                
                // è¡¨ç¤ºã‚’æ›´æ–°
                const stats = state.keywordStats[keyword] || { correctCount: 0 };
                document.getElementById('correct-count').textContent = `æ­£è§£: ${stats.correctCount}/${value}å›ç›®`;
            }
        }

        // è¶…ä½é€Ÿãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleSlowMode() {
            state.slowMode = !state.slowMode;
            const btn = event.target;
            if (state.slowMode) {
                btn.style.backgroundColor = '#dc3545';
                btn.style.color = 'white';
                alert('è¶…ä½é€Ÿãƒ¢ãƒ¼ãƒ‰ ON\næ–‡å­—ã”ã¨ã«0.8ç§’é–“éš”ã§èª­ã¿ä¸Šã’ã¾ã™\né€šå¸¸ã®é€Ÿåº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¯ç„¡åŠ¹ã«ãªã‚Šã¾ã™');
            } else {
                btn.style.backgroundColor = '';
                btn.style.color = '';
                alert('è¶…ä½é€Ÿãƒ¢ãƒ¼ãƒ‰ OFF');
            }
        }

        // è¶…ä½é€Ÿèª­ã¿ä¸Šã’
        function speakSlowly(text) {
            const chars = text.split('');
            chars.forEach((char, i) => {
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(char);
                    utterance.rate = 0.1;
                    utterance.lang = 'ja-JP';
                    if (state.voices.length > 0) {
                        utterance.voice = state.voices[0];
                    }
                    speechSynthesis.speak(utterance);
                }, i * 800); // 0.8ç§’ã”ã¨ã«1æ–‡å­—
            });
        }

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ãƒ‡ãƒ¼ã‚¿åŒæœŸãƒ‘ãƒãƒ«ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleSyncPanel() {
            const panel = document.getElementById('sync-panel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
        function copyDataToClipboard() {
            const data = {
                keywords: {
                    new: state.keywords.new,
                    learning: state.keywords.learning,
                    mastered: state.keywords.mastered
                },
                stats: state.keywordStats,
                mistakes: state.mistakeLog,
                text: elements.textInput.value,
                requiredCounts: state.requiredCounts,
                timestamp: new Date().toISOString()
            };
            
            const jsonData = JSON.stringify(data, null, 2);
            
            // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
            if (navigator.clipboard) {
                navigator.clipboard.writeText(jsonData).then(() => {
                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\nä»–ã®ãƒ‡ãƒã‚¤ã‚¹ã§è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚');
                }).catch(() => {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    const textarea = document.createElement('textarea');
                    textarea.value = jsonData;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
                });
            }
        }

        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒãƒ¼ã‚¸æ–¹å¼ï¼‰
        function loadDataFromClipboard() {
            const input = document.getElementById('sync-data-input');
            const jsonData = input.value.trim();
            
            if (!jsonData) {
                alert('ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const data = JSON.parse(jsonData);
                
                // ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                if (!data.keywords || !data.timestamp) {
                    throw new Error('ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿å½¢å¼');
                }
                
                if (confirm(`${new Date(data.timestamp).toLocaleString('ja-JP')} ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸ã—ã¾ã™ã€‚\nç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã¨çµ±åˆã•ã‚Œã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`)) {
                    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸
                    const mergedKeywords = mergeKeywordData(state.keywords, data.keywords);
                    state.keywords = mergedKeywords;
                    
                    // çµ±è¨ˆæƒ…å ±ã‚‚ãƒãƒ¼ã‚¸ï¼ˆå¤§ãã„æ–¹ã‚’æ¡ç”¨ï¼‰
                    if (data.stats) {
                        Object.keys(data.stats).forEach(keyword => {
                            if (!state.keywordStats[keyword] || 
                                (data.stats[keyword].correctCount > state.keywordStats[keyword].correctCount)) {
                                state.keywordStats[keyword] = data.stats[keyword];
                            }
                        });
                    }
                    
                    // é–“é•ã„ãƒ­ã‚°ã‚‚ãƒãƒ¼ã‚¸
                    if (data.mistakes) {
                        data.mistakes.forEach(mistake => {
                            const existing = state.mistakeLog.find(m => m.word === mistake.word);
                            if (existing) {
                                existing.count = Math.max(existing.count || 1, mistake.count || 1);
                                if (mistake.lastMistake > existing.lastMistake) {
                                    existing.lastMistake = mistake.lastMistake;
                                }
                            } else {
                                state.mistakeLog.push(mistake);
                            }
                        });
                    }
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
                    localStorage.setItem('gijutsushiKeywords_new', JSON.stringify(state.keywords.new));
                    localStorage.setItem('gijutsushiKeywords_learning', JSON.stringify(state.keywords.learning));
                    localStorage.setItem('gijutsushiKeywords_mastered', JSON.stringify(state.keywords.mastered));
                    localStorage.setItem('gijutsushiKeywordStats', JSON.stringify(state.keywordStats));
                    localStorage.setItem('gijutsushiMistakes_integrated', JSON.stringify(state.mistakeLog));
                    
                    // æœ¬æ–‡ã‚‚å¿…è¦ã«å¿œã˜ã¦æ›´æ–°
                    if (data.text && !elements.textInput.value.trim()) {
                        elements.textInput.value = data.text;
                        saveTextToLocal();
                    }
                    
                    // å¿…è¦æ­£è§£æ•°ã®è¨­å®šã‚‚ãƒãƒ¼ã‚¸
                    if (data.requiredCounts) {
                        state.requiredCounts = data.requiredCounts;
                        localStorage.setItem('gijutsushiRequiredCounts', JSON.stringify(state.requiredCounts));
                    }
                    
                    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¿ãƒ–ã®è¡¨ç¤ºã‚’æ›´æ–°
                    elements.keywordTextarea.value = state.keywords[state.currentKeywordTab].join('\n');
                    
                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸ã—ã¾ã—ãŸï¼\nè™«é£Ÿã„å•é¡Œã¯ç¾åœ¨ã®çŠ¶æ…‹ã‚’ç¶­æŒã—ã¾ã™ã€‚');
                    
                    // ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
                    toggleSyncPanel();
                    input.value = '';
                }
            } catch (error) {
                alert('ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\næ­£ã—ã„å½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚');
                console.error('åŒæœŸã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒ¼ã‚¸å‡¦ç†
        function mergeKeywordData(current, incoming) {
            const merged = {
                new: [...current.new],
                learning: [...current.learning],
                mastered: [...current.mastered]
            };
            
            // å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é©åˆ‡ãªãƒ¬ãƒ™ãƒ«ã«é…ç½®
            const allKeywords = new Set([
                ...current.new, ...current.learning, ...current.mastered,
                ...incoming.new, ...incoming.learning, ...incoming.mastered
            ]);
            
            allKeywords.forEach(keyword => {
                // ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã¨èª­ã¿è¾¼ã¿ãƒ‡ãƒ¼ã‚¿ã®ãƒ¬ãƒ™ãƒ«ã‚’ç¢ºèª
                let currentLevel = null;
                let incomingLevel = null;
                
                if (current.new.includes(keyword)) currentLevel = 'new';
                else if (current.learning.includes(keyword)) currentLevel = 'learning';
                else if (current.mastered.includes(keyword)) currentLevel = 'mastered';
                
                if (incoming.new.includes(keyword)) incomingLevel = 'new';
                else if (incoming.learning.includes(keyword)) incomingLevel = 'learning';
                else if (incoming.mastered.includes(keyword)) incomingLevel = 'mastered';
                
                // ã‚ˆã‚Šé€²ã‚“ã§ã„ã‚‹æ–¹ã‚’æ¡ç”¨
                const levelPriority = { 'new': 0, 'learning': 1, 'mastered': 2 };
                const finalLevel = (currentLevel && incomingLevel) ? 
                    (levelPriority[currentLevel] > levelPriority[incomingLevel] ? currentLevel : incomingLevel) :
                    (currentLevel || incomingLevel);
                
                // é‡è¤‡ã‚’å‰Šé™¤
                merged.new = merged.new.filter(k => k !== keyword);
                merged.learning = merged.learning.filter(k => k !== keyword);
                merged.mastered = merged.mastered.filter(k => k !== keyword);
                
                // é©åˆ‡ãªãƒ¬ãƒ™ãƒ«ã«è¿½åŠ 
                if (finalLevel) {
                    merged[finalLevel].push(keyword);
                }
            });
            
            return merged;
        }

        // åˆæœŸåŒ–å®Ÿè¡Œ
        initialize();
    </script>
</body>
</html>
